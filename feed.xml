<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-26T16:26:03+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">프로시저와 함수</title><link href="http://localhost:4000/db/sql/2022/04/26/procedure.html" rel="alternate" type="text/html" title="프로시저와 함수" /><published>2022-04-26T00:00:00+09:00</published><updated>2022-04-26T00:00:00+09:00</updated><id>http://localhost:4000/db/sql/2022/04/26/procedure</id><content type="html" xml:base="http://localhost:4000/db/sql/2022/04/26/procedure.html"><![CDATA[<h2 id="프로시저와-함수">프로시저와 함수</h2>

<p>프로시저와 함수의 정의와 차이점</p>

<h2 id="프로시저">프로시저</h2>

<p>프로시저 : 업무를 수행하기 위한 절차.</p>

<p>플세스를 절차적으로 기술해 놓은것이 프로시저라 한다.</p>

<p>프로시저 문법</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>create or replace proceure 프로시저명
    \(매개변수명1 \[in \|| out \|| inout] 데이터타입,
     매개변수명2 \[in \|| out \|| inout] 데이터타입...)
     is \|| as
        변수, 상수 등 선언(선언부)
     begin
        실행문장(실행부)
        eception 문장 // 필수아님
    end ;
</code></pre></div></div>

<p>예제</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 사번을 입력받아 급여를 인상하는 update_sal  프로시저
create or replace procedure update_sal
    (v_empno in number)
is
begin
    update emp
    set sal = sal*1.1
    where empno = v_empno;
end update_sal;
</code></pre></div></div>

<h2 id="함수">함수</h2>

<p>위 프로시저의 각 프로세스를 수행하기 위해 필요한 기능을 함수라 한다.</p>

<p>함수 문법</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>create or replace funtion 함수명
    (매개변수명1 매개변수1타입,
     매개변수명2 매개변수2타입...)
return 데이터타입
is \|| as
    변수, 상수등을 선언(선언부)
begin
    실행 문장(실행부)
return 반환값 //필수
exception 문장 //필수아님
end;
</code></pre></div></div>
<p>함수 예제</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 날짜를 입력하면 yyy-mm-dd 형태로 바꿔주느 하무
create or replace funtion testDate( date Date)
return varchar2
is
    changeDate varchar2(20);
begin 
    changeDate := null;
    changeDate := TO_CHAR (date, 'yyyy-mm-dd');
    return changeDate;
end;
</code></pre></div></div>

<h2 id="함수와-프로시저의-차이">함수와 프로시저의 차이</h2>

<table>
  <tbody>
    <tr>
      <td>프로시저</td>
      <td>함수</td>
    </tr>
    <tr>
      <td>특정한 작업을 수행</td>
      <td>특정한 계산을 수행</td>
    </tr>
    <tr>
      <td>리턴값을 가질수도 안가질수도 있음</td>
      <td>리턴값을 반드시 가져야함</td>
    </tr>
    <tr>
      <td>리턴값을 여러개 가질수 있음</td>
      <td>리턴값을 오직 하나만 가질 수 있음</td>
    </tr>
    <tr>
      <td>서버(DB)단에서 기술</td>
      <td>화면(client)단에서 기술</td>
    </tr>
    <tr>
      <td>수식내에서 사용 불가</td>
      <td>수식내에서만 사용 가능</td>
    </tr>
    <tr>
      <td>단독으로 문장 구성 가능</td>
      <td>단독으로 문장 구성 불가</td>
    </tr>
  </tbody>
</table>]]></content><author><name>GitHub User</name></author><category term="DB" /><category term="sql" /><category term="DB" /><category term="sql" /><summary type="html"><![CDATA[프로시저와 함수]]></summary></entry><entry><title type="html">sql</title><link href="http://localhost:4000/db/sql/2022/04/26/sql.html" rel="alternate" type="text/html" title="sql" /><published>2022-04-26T00:00:00+09:00</published><updated>2022-04-26T00:00:00+09:00</updated><id>http://localhost:4000/db/sql/2022/04/26/sql</id><content type="html" xml:base="http://localhost:4000/db/sql/2022/04/26/sql.html"><![CDATA[<h2 id="sql">sql</h2>

<p>sql (structured query language) 프로그래밍 언어의 한 종류지만 범용적인 프로그래밍 언어와는 다른
관계형 데이터베이스 전용 언어이다. 약 30개의 명령어로 구성된 표준 릴레이션 언어로 상업 목적 모든 데이터베이스 제품에서
지원하고 있으며 많은 소프트웨어 업체들이 기본적인 sql 명령어들을 확장시켜 오고 있다.</p>

<h2 id="sql-특징">sql 특징</h2>

<p>비절차적 언어로 사용자가 프로그램을 작성할 때 데이터 연상에 대한 처리 과정을 명시하는 것이 아닌, 단지 데이터로부터 얻고자하는 연산 결과만을 명시하도록 한다. 다른언어와 달리 사용자 편의 중심언어라는 의미로 사용자 관점에서 어떻게 행해지는 것 보다는 무엇을 해야하는지를 명시하는 언어임을 의미한다.</p>

<h3 id="종류">종류</h3>

<ul>
  <li>
    <p>dml: 데이터 조작언어 등록, 삭제, 수정을 위한 데이터베이스 언어 또는 데이터베이스 언어 요소이다.</p>

    <ul>
      <li>select : 하나 또는 그 이상의 테이블에서 데이터를 추출하는 sql dml 용어중 하나이다.
  결과를 얻기위해 어떤 물리적인 작업이 수행되는지를 지시하지 않아도 데이터베이스 시스템(쿼리 최적화)이 sql 문에서 최적의 쿼리계획(실행계획) 을 작성한다.</li>
    </ul>

    <p>사용함수</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  where: 어떤 열을 불러올지를 결정
  group by: 연산 함수가 각 그룹에 적용되게 하도록 속성을 그룹 열에 공유하는 것
  having : group by 절에서 정의된 그룹 중에서 검색
  order by: 반환되는 열의 정렬 순서를 지정
</code></pre></div>    </div>

    <p>예제</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 사번이 7900, 7934번인 사원의 사번과 성명 출력
  select empno, ename
  from emp
  where empno in (7900,7934);
</code></pre></div>    </div>

    <ul>
      <li>insert: 테이블에 데이터를 추가한다 컬럼의 순서와 값의 순거가 같아야 해당 컬럼으로 데이터가 추가된다.</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  insert into table_name or view_name (column1,column2....)
  values (value1,value2...);
</code></pre></div>    </div>

    <p>또는 모든 컬럼의 값을 등록할 떄 대상 컬럼 명을 생략할 수 있다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  insert into table or view 
  values (value1,value2...);
</code></pre></div>    </div>

    <p>예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 모든 데이터
  INSERT INTO emp VALUES (7369, '박지성', '사원', 7902, TO_DATE('1980/12/17','YYYY-MM-DD'),  800, NULL,  20);
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //원하는 데이터만
  INSERT INTO emp (empno, ename) VALUES (7369, '박지성');
</code></pre></div>    </div>

    <ul>
      <li>update : 구조화 질의어 중 하나로, 테이블이나 뷰에서 한개 이상의 행을 바꾼다. 모든 행을 변경해야 하는 경우도 조건절을 사용하여 하위 집합을 선택할 수 있다.
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  UPDATE table_name 
  SET    column_name = value 
  [, column_name = value]
  [, ...]
  [WHERE condition]
</code></pre></div>        </div>
      </li>
    </ul>

    <p>업데이트가 성공적으로 이루어진 경우, 사용자는 반드시 데이터 조작 특권 동작을 반드시 테이블이나 컬럼에서 수행해야하고 업데이트 된 값은 제약조건에 충돌하지 않아야 한다. 고유키,고유 인데스,check 제약조건, not null 제약조건등이 있다.</p>

    <p>예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //직원의 급여를 2500000으로 변경하는 경우
  update emp
  set    salary = 2500000
  where  ename  = 'employee';
</code></pre></div>    </div>

    <ul>
      <li>delete : 테이블 또는 뷰에서 한개 이상의 행을 삭제한다 하위 집합은 삭제에 대한 조건을 정의할 수 있으며, 정의하지 않으면 모든 행이 삭제된다.</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  delete from table
  where column;
</code></pre></div>    </div>

    <p>예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //emp 테이블 전체 데이터 삭제
  delete from emp;
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // emp 테이블에서 사원명이  'employee' 인 데이터를 삭제
  delete from emp
  where ename = 'employee';
</code></pre></div>    </div>
  </li>
  <li>
    <p>ddl: 데이터 구성요소 정의 및 변경 삭제 처리 언어 
  스키마 객체를 생성, 변경 ,삭제할 수 있다.
  create, alter, drop 명령어는 작업할 객체에 단독으로 접근해야 한다. 
  다른 사용자가 작업할 테이블에 트랜잭션을 열고 있다면 자신의 alter table 문장은 실패한다.</p>

    <ul>
      <li>
        <p>create : 테이블, 시퀀스, 인덱스, 뷰 등과 같이 객체를 생성하는데 사용한다.</p>

        <ul>
          <li>테이블 명은 다른테이블의 이름과 중복될 수 없다.</li>
          <li>한 테이블 내에서 컬럼 명은 중복될 수 없다.</li>
          <li>테이블 명은 영문자로 시작해야 한다.</li>
          <li>내장 키워드는 테이블 명 또는 컬럼 명으로 사용할 수 없다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  create table table_name (

      column1 datetype(size) [default value],
      column2 datetype(size) [default value]...
  );
</code></pre></div>    </div>

    <h3> constraint(제약조건) </h3>

    <ul>
      <li>
        <p>PRIMARY KEY (기본키,PK) : 테이블 내의 개별 데이터를 식별하기 위해 정의된 제약조건이다.
  이 조건을 설정한 컬럼의 데이터는 컬럼 내에서 중복될 수 없으며 null값을 허용하지 않는다.
  pk는 uniqe + not null 의 제약조건을 갖는다.</p>
      </li>
      <li>
        <p>FOREIGN KEY (외래키, FK) : 부모 테이블과 자식 테이블 간의 관계를 정의하기 위해 부모 테이블의 PK값을 참조하는 자식 테이블의 제약조건이다.</p>
      </li>
      <li>
        <p>UNIQUE KEY (고유키, UK) : 테이블 내의 개별 데이터를 고유하게 식별하기 위한 제약조건이다.</p>
      </li>
      <li>
        <p>NOT NULL (NN) : 해당 컬럼의 데이터값에 Null을 허용하지 않는 제약조건이다. 즉 필수입력을 의미한다.</p>
      </li>
      <li>
        <p>CHECK (CK) : 해당 컬럼에 허용할 수 있는 데이터 값의 범위를 제한한다.</p>
      </li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  CREATE TABLE table_name (

  column_name1 데이터타입(크기) [DEFAULT value],
  column_name2 데이터타입(크기) [DEFAULT value],
  CONSTRAINT constraint_name constraint_type(column1[, column2...]),
  ...
);
</code></pre></div>    </div>
  </li>
  <li>
    <p>SEQUENCE</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE SEQUENCE sequence_name

    [INCREMENT BY n]        -- 증가 값
    [START WITH n]          -- 시작 값
    [MINVALUE n]            -- 최소 값
    \[MAXVALUE n|NOMAXVALUE] -- 최대 값
    \[CYCLE|NOCYCLE]         -- 최대 값 이후 시작 값으로 되돌아갈지 여부
    \[CACHE n|NOCACHE]       -- 시퀀스 생성 캐싱 여부 및 캐쉬 값
;
</code></pre></div></div>

<ul>
  <li>INDEX : 테이블의 칼럼을 색인화(따로 파일로 저장) 하여 검색시 테이블의 레코드를 전부 스캔하는게 아니라 색인화된 인덱스 파일을 검색하여 검색속도를 빠르게 한다.</li>
</ul>

<p>select 쿼리의 where 절이나 join 예약어를 사용했을때 사용디며 select 쿼리의 검색속도를 빠르게 하는데 목적을 두고 있다.
(delete, insert, update 쿼리는 해당사항이 없으며 사용시 더 느려진다.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE INDEX index_name on table_name (column_name[,column_name...]);
</code></pre></div></div>

<ul>
  <li>VIEW</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE OR REPLACE VIEW view_name (column_name1[,column_name2...]) AS
    SELECT column_name1[,column_name2...]
    FROM table_name;
</code></pre></div></div>

<ul>
  <li>
    <p>ALTER : ALTER Table, ALTER Sequences, ALTER Index, ALTER View 등과 같이 객체를 변경하는 데 사용한다.</p>

    <ul>
      <li>ADD (컬럼 추가)</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALTER TABLE table_name 
  ADD (컬럼1 데이터타입(크기) [제약조건], 컬럼2 데이터타입(크기)...);
</code></pre></div>    </div>

    <ul>
      <li>MODIFY (컬럼 유형 변경)</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //컬럼 유형 변경
  ALTER TABLE table_name 
      MODIFY (컬럼1 데이터타입(크기), 컬럼2 데이터타입(크기)...);
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //제약조건 변경
  ALTER TABLE table_name 
      MODIFY (컬럼1 CONSTRAINT 제약조건명 제약조건(컬럼명 조건식));
</code></pre></div>    </div>
  </li>
  <li>
    <p>RENAME : 테이블과 컬럼의 이름을 변경하는 데 사용한다.</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//테이블명 변경
RENAME from_table_name TO to_tale_name;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//컬럼명 변경
ALTER TABLE table_name 
    RENAME COLUMN from_col_name TO to_col_name;
</code></pre></div></div>

<ul>
  <li>DROP : DROP Table, DROP Sequences, DROP Index, DROP View 등과 같이 개체를 삭제하는 데 사용한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//테이블, 시퀀스, 인덱스, 뷰 삭제
DROP TABLE table_name;
DROP SEQUENCE sequence_name;
DROP INDEX index_name;
DROP VIEW view_name;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//테이블과 함께 참조된 제약조건을 모두 삭제할 경우
DROP TABLE table_name CASCADE CONSTRAINTS;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//컬럼 삭제
ALTER TALLE table_name DROP COLUMN column_name;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//삭제할 컬럼에 제약조건이 존재할 경우
ALTER TABLE table_name DROP COLUMN column_name CASCADE CONSTRAINTS;
</code></pre></div></div>

<ul>
  <li>TRUNCATE : 테이블에서 영구적으로 모든 행을 삭제할 때 이 구문을 사용하며 “DELETE FROM table_name” 구문과 동일하다. 이 구문은 롤백 되지 않는다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TRUNCATE TABLE table_name;
</code></pre></div></div>

<ul>
  <li>
    <p>dcl: 데이터 접근 또는 권한을 제어 언어 , 무결성(integrty), 보안(security), 회복(recovery), 동시성(concurrency) 을 위해 사용자별 데이터 베이스 접근 또는 사용 권한을 부여 또는 제거하여 데이터를 보호 관리하는 언어이다.</p>

    <ul>
      <li>
        <p>grant : 데이터베이스 사용자에게 특정 작업에 대한 수행 권한을 부여할 수 있는 권한</p>

        <p>권한부여</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  grant [권한] on [db].[table] to [user_id]@[host];
</code></pre></div>        </div>

        <p>사용자 등록 및 권한부여</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  grant [권한] on [db].[table] to [user_id]@[host] identified by 'password';
</code></pre></div>        </div>

        <p>권한 확인</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  show grants for [user_id]@[host];
</code></pre></div>        </div>

        <p>예제</p>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //사용자에게 테이블의 select, insert, update, delete, create, drop, index, alter 
  //권한을 부여
  grant select,  insert, update, delete, create, drop, index, alter on (table) to user;
</code></pre></div>        </div>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //사용자 에게 테이블의 모든 권한을 부여
  grant all privleges on (table) to user;
</code></pre></div>        </div>
      </li>
      <li>
        <p>revoke : 데이터베이스 사용자에게 특정 작업에 대한 수행 권한을 박탈, 회수할 수 있는 권한</p>
      </li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  revoke [권한] on [DB].[table] from [user_id]@[host]
</code></pre></div>    </div>

    <ul>
      <li>commit : 트랜잭션의 작업이 정상적으로 완료할 수 있는 권한</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  commit;
</code></pre></div>    </div>

    <ul>
      <li>rollback : 트랜잭선의 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구할 수 있는 권한</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  rollback;
</code></pre></div>    </div>
  </li>
  <li>
    <p>트랜젝션 제어: dml에 대한 사용자별 트랜젝션 관리</p>
  </li>
</ul>

<h3 id="호스트-언어-필요">호스트 언어 필요</h3>

<p>데이터베이스를 이용하는 어플리케이션을 실제로 작성하려면 데이터베이스와 대화하는 것 외에도 사용자 인터페이스를 설계한다거나,
네트워크의 기능을 넣는다거나 등의 여러 가지 일을 구현하지 않으면 안된다.</p>

<p>sql 자체가 범용적인 프로그래밍 언어가 아니기 때문에 모든 작업을 sql로만 할 수는 없다. sql 에는 다른 언어로 부터 호출받기 위한 인터페이스가 준비되어 있다.</p>

<p>범용적인 프로그래밍 언어가 일반적인 처리를 맡고, 데이터베이스를 처리할 필요가 발생할 떄에만 sql을 호출한다.</p>

<p>sql을 호출하는 언어를 호스트 언어라고 한다.</p>

<p>sql 호출법</p>

<ul>
  <li>
    <ol>
      <li>직접호출: 컴퓨터에 sql문을 입력하고 직접 실행</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>내장 sql(정적sql) : 호스트 언어의 프로그래밍 코드 속에 직접 sql문을 기술</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>모듈호출: 단일 sql문으로 구성되어 있는 모듈(함수)을 호스트 언어로부터 외부 절차(서브루틴)로 호출하는 방법으로
어플ㄹ케이션과 모듈 간에 값을 인도할 때는 파라미터와 반환 값을 사용한다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>동적 sql: 호스트 언어의 실행 시에 sql문을 생성하는 방법으로 성능면에서는 내장 sql보다 좋지 않지만, 유연성이 높은 어플리케이션을 개발할 수 있는 장점이 있다.</li>
    </ol>
  </li>
</ul>]]></content><author><name>GitHub User</name></author><category term="DB" /><category term="sql" /><category term="DB" /><category term="sql" /><summary type="html"><![CDATA[sql]]></summary></entry><entry><title type="html">springboot mvc</title><link href="http://localhost:4000/springboot/2022/04/25/springboot-mvc.html" rel="alternate" type="text/html" title="springboot mvc" /><published>2022-04-25T00:00:00+09:00</published><updated>2022-04-25T00:00:00+09:00</updated><id>http://localhost:4000/springboot/2022/04/25/springboot-mvc</id><content type="html" xml:base="http://localhost:4000/springboot/2022/04/25/springboot-mvc.html"><![CDATA[<h2 id="spring">spring</h2>

<p>스프링은 자바 기반의 웹 어플리케이션을 만들 수 있는 프레임워크 이다.
스프링 프레임워크는 현대 자바 기반의 엔터프라이즈 어플리케이션을 위한 프로그래밍 및
configuration model을 제공한다.</p>

<p>파이썬을 이용한 django, Ruby를 이용한 Rub on Rails, 자바스크립트를 이용한 node.js 기반의 웹서버 개발과 같이
java 개발자들은 스프링을 사용하여 웹 서비스를 만들수있습니다.</p>

<p>자바 백엔드 개발자는 웹 애플리케이션을 개발할 때, 대부분 스프링을 사용한다고 한다.</p>

<h2 id="spring의-특징">spring의 특징</h2>

<ul>
  <li>
    <p>자바 객체와 라이브러리들을 관리, 톰캣과 같은 WAS 가 내장되어 있어 자바 웹 어플리케이션을 구동 가능</p>
  </li>
  <li>
    <p>경량 컨테이너로 자바 객체를 직접 스프링 안에서 관리합니다. 객체의 생성 및 소멸 같은 생명 주기를 관리하며
스프링 컨테이너 에서 필요한 객체를 가져와 사용합니다.</p>
  </li>
  <li>
    <p>IOC 와 DI</p>

    <ul>
      <li>
        <p>IOC란 제어의 역전으로 기존에는 각 객체들이 프로그램의 흐름을 결정하고 각 객체를 직접 생성하고 조작하는작업(객체를 직접 생성하여 메소드 호출)을 했었다. 즉 모든 작업을 사용자가 제어하는 구조
  ex) A 객체에서 B 객체에 있는 메소드를 사용하고 싶으면 B 객체를 직접 A 객체 내에서 생성하고 메소드를 호출</p>
      </li>
      <li>
        <p>하지만 IOC 가 적용된 경우, 객체의 생성을 특별한 관리 위임 주체에게 맡긴다. 즉 사용자가 객체를 직접 생성하지 않고,
  객체 생명 주기를 컨트롤 하는 주체는 다른 추체가 된다. 사용자의 제어권을 다른추체에게 넘기는 것 =IOC
  ex) 스프링에 제어를 위임 스프링이 만든 객체 주입 -&gt; 의존성 객체의 메소드 호출</p>
      </li>
      <li>
        <p>스프링이 실행될때 모든 의존성 객체를 만들어주고 필요한 곳에 주입</p>
      </li>
      <li>
        <p>DI란 의존성 주입 이다. 어떤 객체(b)를 사용하는 주체(a)가 객체(b)를 직접 생성하는게 아니라 객체를 외부(spring)
  에서 생성해서 사용하려는 주체 객체(a)에 주입시켜주는 방식
  사용하려는 추체가 사용하려는 객체를 직접 생성하는 경우 의존성 이 높아진다. 하지만 외부에서 직접 생성하여 관리하는경우에는
  주체와 객체의 의존성이 줄어든다.</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="spring-boot">spring boot</h2>

<p>스프링 부트는 스프링을 더 쉽게 이용하기 위한 도구.</p>

<p>스프링을 이용하여 개발을 할 때, 이것저것 세팅을 해야 될 요소들이 많다. -&gt; 진입장벽</p>

<p>스프링 부트는 매우 간단하게 프로젝트를 설정 할 수 있게하여, 스프링 개발을 조금 더 쉽게 만들어주는 역할을 한다.</p>

<p>프로그래밍을 하는 데 있어 매우 중요한 비즈니스를 만들기 위한 프로그래밍에 조금 더 에너지를 투입할 수 있게 스프링에 많은 부분
자동화를 하였고, 많은 개발자들이 스프링 부트를 이용하여 개발을 한다.</p>

<h2 id="mvc">mvc</h2>

<p>mvc란 모델(model)-뷰(view)-컨트롤러(controller)이며 이는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴을 의미한다.</p>

<p>mvc를 성공적으로 사용하면 사용자 인터페이스로 부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.</p>

<ul>
  <li>
    <p>모델 - 애플리케이션의 정보(데이터) 모델의 상태에 변화가 있을 때 컨트롤러와 뷰에 이를 통보한다. 이와같은 통보를 통해서 뷰는 최신정보를 보여줄 수 있고, 컨트롤러는 모델의 변화에 따른 적용 가능한 명령을 추가, 제거, 수정할 수 있다.</p>
  </li>
  <li>
    <p>뷰 - 텍스트, 체크박스 항목등의 사용자 인터페이스 요소 사용자가 볼 결과물을 생성하기 위해 모델로부터 정보를 얻어온다.</p>
  </li>
  <li>
    <p>컨트롤러 - 데이터와 비즈니스 로직 사이의 상호동작 관리 모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.(워드 프로세스에서 문서를 편집하는 것)또, 컨트롤러가 관련된 뷰에 명령을 보냄으로써 모델의 표시 방법을 바꿀 수 있다.(문서를 스크롤 하는 것).</p>
  </li>
  <li>
    <p>원리 - 자바언어에서 모델은 java.util.Observable 을 상속(extends)받아 만들 수 있다. 모델에는 현재 상태 정보를 변경하거나 다른 클래스에게 알릴 수 있는 함수가 있어야 한다. 모델의 상태를 변경하는 함수는 setChanged()와 notifyObservers()를 호출하여야 한다. notifyObservers는 모델에 등록된 모든 뷰에게 업데이트 메시지를 보내게 된다.
뷰는 java.util.Observer를 implement 하여 만들면 update method 를 구현할 수 있다. update함수의 두 번쨰 매개변수는
object 모델에서 넘어온 추가정보를 받는 데 사용된다.
뷰는 반드시 모델에게 질의하여 엄데이트 하는 부분이 구현되어야 한다. 모델은 addObserver 라는 함수를 이용하여 뷰를 자신에게 등록시킨다.
모델은 자신에게 등록된 모든 뷰를 기억하고 있다가 자신의 상태가 바뀌게 되면 등록된 모든 뷰에 notify 함수를 호출하여 뷰를 update시킨다. 모델은 뷰를 여러 개 가질 수 있다. MVC 에서는 이것을 허용하고있다. 또한 뷰도 여러개의 모델에 등록될 수 있다.</p>
  </li>
</ul>

<h2 id="spring-boot-mvc">spring boot mvc</h2>

<p>스프링 웹 계층</p>

<ul>
  <li>
    <ol>
      <li>web layer</li>
    </ol>

    <ul>
      <li>
        <p>컨트롤러(@controller) 가 대표적이고, 이외에도 필터(@filter), 인터셉터, 컨트롤러 어드바이스 등이 포함된다.</p>
      </li>
      <li>
        <p>외부 요청과 응답에 대한 전반적인 영역을 의미한다.</p>
      </li>
    </ul>
  </li>
  <li>
    <ol>
      <li>service layer</li>
    </ol>

    <ul>
      <li>
        <p>말 그대로 서비스(@service)이다.</p>
      </li>
      <li>
        <p>일반적으로 컨트롤러와 저장소(Repository, Dao)의 중간에 위치한다.</p>
      </li>
      <li>
        <p>트랜잭션(@Transactional)과 도메인 간의 연산 순서를 보장해 준다.</p>
      </li>
    </ul>
  </li>
  <li>
    <ol>
      <li>Repository layer</li>
    </ol>

    <ul>
      <li>
        <p>DB와 같은 데이터 저장소에 접근하는 영역이다.</p>
      </li>
      <li>
        <p>JPA를 사용한다면 @Repository를 생각하면 된다.</p>
      </li>
    </ul>
  </li>
  <li>
    <ol>
      <li>DTOs</li>
    </ol>

    <ul>
      <li>DTO(Date Transfer Object)는 계층 간의 데이터 교환을 위한 객체를 이야기한다.</li>
    </ul>
  </li>
  <li>
    <ol>
      <li>Domain model</li>
    </ol>

    <ul>
      <li>
        <p>개발대상, 즉 도메인을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화한 것을 도메인 모델이라고 한다.</p>
      </li>
      <li>
        <p>비즈니스 로직을 처리하는 영역이다.</p>
      </li>
      <li>
        <p>JPA를 사용한다면, @Entity가 사용되는 영역 역시 도메인 영역아리고 생각할 수 있다.</p>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>GitHub User</name></author><category term="springboot" /><category term="springboot" /><summary type="html"><![CDATA[spring]]></summary></entry><entry><title type="html">CI/CD jenkins</title><link href="http://localhost:4000/jenkins/2022/04/25/CICD.html" rel="alternate" type="text/html" title="CI/CD jenkins" /><published>2022-04-25T00:00:00+09:00</published><updated>2022-04-25T00:00:00+09:00</updated><id>http://localhost:4000/jenkins/2022/04/25/CICD</id><content type="html" xml:base="http://localhost:4000/jenkins/2022/04/25/CICD.html"><![CDATA[<h2 id="cicd">CI/CD</h2>

<p>CI/CD 는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법.</p>

<p>CI/CD 의 기본 개념은 지속적인 통합,지속적인 서비스 제공, 지속적인 배포.</p>

<p>새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제를 해결하기 위한 솔루션</p>

<p>애플리케이션 통합 및 테스트 단계에서부터 제공 및 배포에 이르는 애플리케이션의 라이프 사이클 전체에 걸쳐 지속적인 자동화와 지속적인 모니터링을 제공. &lt;- CI/CD 파이프라인이라 부르며 개발 및 운영팀의 애자일 방식 협력을 통해 지원된다.</p>

<h2 id="ci-와-cd-의-차이점">CI 와 CD 의 차이점</h2>

<ul>
  <li>
    <p>CI(Continuous Intergration) : 성공적으로 구현할 시 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 리포지토리에 통합 됨 -&gt; 여러명의 개발자가 동시에 애플리케이션 개발과 관련 코드 작업시 서로 충돌할 수 있는 문제를 해결.</p>
  </li>
  <li>
    <p>CD : 지속적인 서비스 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며 상호 교환적으로 사용. 두가지 모두 파이프라인의 추가 단계에 대한 자동화를 뜩하지만 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.</p>

    <ul>
      <li>
        <p>지속적인 제공 : 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드 되는 것을 의미하며 리포지토리에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있다. -&gt; 개발팀과 비즈니스팀 간의 가시성과 커뮤니케이션 부족 문제를 해결해준다. 최소한의 노력으로 새로운 코드를 배포하는 것을 목표</p>
      </li>
      <li>
        <p>지속적인 배포 : 개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스 하는것을 의미한다. -&gt; 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결.
  파이프 라인의 다음 단계를 자동화 함으로 써 지속적인 제공이 가진 장점을 활용한다.</p>
      </li>
    </ul>
  </li>
</ul>

<p>CI/CD 는 지속적 통합 및 지속적 제공의 구축사례만을 지칭하 거나 지속적제공,통합,배포 3가지 구축사례 모두를 의미하는 것 일수도 있다. -&gt; 지속적인 서비스제공은 떄로 지속적인 배포의 과정까지 포함하는 방식으로 사용되기도 한다.</p>

<p>결과적으로 CI/CD는 파이프라인으로 표현되는 실제 프로세스를 의미 애플리케이션 개발에 지속적인 자동화 및 지속적인 모니터링을 추가하는 것을 의미한다.</p>

<p>사례별로 CI/CD 구현된 자동화 수준 정도에 따라 의마가 달라진다 대부분 기업은 CI를 먼저 추가한 후 클라우드 네이티브 애플리케이션의 일부로서 배포 및 개발 자동화를 구현해나간다.</p>

<h2 id="ci">CI</h2>

<p>현대적 애플리케이션 개발에서는 여러 개발자들이 동일한 애플리케이션의 각기 다른 기능을 동시 작업할 수 있도록 하는 것을 목표로한다.</p>

<p>그러나 조직에서 특정한 날을 정해 모든 분기 소스 코드를 병합하는 경우, 결과적으로 반복적인 수작업에 많은 시간을 소모하게 된다.
-&gt; 반복적인 수작업의 이유론 독립적으로 작업하는 개발자가 애플리케이션에 변경 사항을 적용할 때 다른 개발자가 동시에 적용하는 변경 사항과 충돌 할 가능성이 있기 때문.</p>

<p>팀이 하나의 클라우드 기반 통합개발환경 사용에 동의하는 대신 각 개발자가 각자 로컬 개발환경을 커스터마이징 하는 경우 복합적인 문제가 될 수 있다.</p>

<p>CI를 통해 개발자들은 코드 변경 사항을 공유 브랜치 또는 “트랭크”로 다시 병합하는 작업을 수월하게 자주 수행할 수 있습니다. 개발자가 어플리케이션에 적용한 변경 사항이 병합되면 변경 사항이 애플리케이션을 손상시키지 않도록 자동으로 애플리케이션을 구축하고 각기 다른 레벨의 자동화 테스트 실행을 통해 변경 사항이 애플리케이션에 제대로 적용되었는지를 확인함.</p>

<p>클래스와 기능에서부터 전체 애플리케이션을 구성하는 서로 다른 모듈에 이르기까지 모든 것에 대한 테스트를 수행한다. 자동화 테스트에서 기존 코드와 신규 코드 간의 충돌이 발견되면 CI를 통해 버그를 빠르게 자주 수정할 수 있습니다.</p>

<h2 id="cd-지속적-제공">CD (지속적 제공)</h2>

<p>CI의 빌드 자동화, 유닛 및 통합 테스트 수행 후, 이어지는 지속적 제공 프로세스에서는 유호한 코드를 리포지토리에 자동으로 릴리즈한다.  -&gt; 효과적인 지속적 제공 프로세스를 실현하기 위해서는 개발 파이프라인에 CI가 먼저 구축되어있어야한다.</p>

<p>지속적 제공의 목표는 프로덕션 환경으로 뱊할 준비가 되어 있는 코드베이스를 확보하는 것이다.</p>

<p>지속적 제공은 코드 변경 사항 병합부터 프로덕션에 적합한 빌드 제공에 이르는 모든 단계에는 테스트 자동화와 코드 릴리스 자동화가 포함된다. 이프로세스를 완료하면 운영팀이 보다 빠르고 손쉽게 애플리케이션을 프로덕션으로 배포 할 수 있게된다.</p>

<h2 id="cd-지속적-배포">CD (지속적 배포)</h2>

<p>CI/CD 파이프라인의 마지막 단계는 지속적 배포이다. 프로덕션 준비가 완료된 빌드를 코드 리포지토리에 자동으로 릴리스하는 지속적 제공의 확잔된 형태인 지속적 배포는 애플리케이션을 프로덕션으로 릴리스하는 작업을 자동화 한다.</p>

<p>프로덕션 이전의 파이프라인 단계에는 수동 작업 과정이 없으므로 지속적 배포가 제대로 이루어지려면 테스트 자동화가 제대로 설계되어야한다.</p>

<p>실 사례에서 지속적 배포란 개발자가 애플리케이션에 변경 사항을 작성한 후 몇 분 이내에 애플리케이션을 자동으로 실행 할 수 있는 것을 의미한다(자동화 된 테스트를 통과한 것으로 간주). 이를 통해 사용자 피드백을 지속적으로 수신하고 통합하는 일이 훨씬 수월해진다.</p>

<p>모든 CI/CD 적용 사례는 애플리케이션 배포ㅢ 위험성을 줄여주므로 애플리케이션 변경 사항을 한번에 모두 릴리스하지 않고 작은 조각으로 세분화하여 더욱 손쉽게 릴리스 할 수 있다. 자동화된 테스트는 CI/CD ㅍ이프라인의 여러 테스트 및 릴리스 단계를 수행 할 수 있어야 하기 떄문에 많은 선행 투자가 필요하다.</p>

<h2 id="jenkins">jenkins</h2>

<p>젠킨스는 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴이다. CI 툴이라고 표현한다.</p>

<p>다수의 개발자들이 하나의 프로그램을 개발 할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유 영역에 있는 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해준다.</p>

<p>개발중인 프로젝트에서 커밋은 빈번히 일어나기 떄문에 커밋 횟수만큼 빌드를 실행하는 것이 아니라 작업이 큐일되어 자신이 실행돌 차례를 기다리게 된다. -&gt; 이같은 자동화된 빌드 테스트 작업들이 주는 이점.</p>

<ul>
  <li>
    <p>프로젝트 표준 컴파일 환경에서의 오류 검출</p>
  </li>
  <li>
    <p>정적 코드 분석에 의한 코딩 규약 준수여부 체크</p>
  </li>
  <li>
    <p>프로파일링 툴을 이용한 소스 변겨에 따른 성능 변화 감시</p>
  </li>
  <li>
    <p>결합 테스트 환경에 대한 배포작업</p>
  </li>
</ul>

<p>이외에도 젠킨스는 500가지가 넘는 플러그인을 온라인으로 간단히 인스톨 할 수 있는 기능을 제공하며 파이썬과 같은 스크립트를 이용하여 손쉽게 자신에게 필요한 기능을 추가 할 수도 있다.</p>

<h3 id="각종-배치-작업의-간략화">각종 배치 작업의 간략화</h3>

<p>프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB셋업이나 환경설정, Deploy작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번하다. 데이터베이스의 구축, 어플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능해졌다.</p>

<h3 id="빌드-자동화의-확립">빌드 자동화의 확립</h3>

<p>빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 젠킨스를 사용하지 않을 이유가 하나도 없다. 젠킨스와 연동하여 빌드 자동화를 통해 프로젝트 진행의 효율성을 높일 수 있다.</p>

<h3 id="자동화-테스트">자동화 테스트</h3>

<p>자동화 테스트는 젠킨스를 사용해야 하는 가장 큰 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않은 빌드는 CI자체가 불가능하다고 봐도 무방하다. 젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 하여도 든든한 안전망이 되어준다. 제대로 테스트를 거치지 않은 코드를 커밋하게 되면 화난 젠킨스를 만나게 된다.</p>

<h3 id="코드-표준-준수여부-검사">코드 표준 준수여부 검사</h3>

<p>자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여한다.</p>

<h3 id="빌드-파이프라인-구성">빌드 파이프라인 구성</h3>

<p>2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따는 빌드 파이프라인 구성이 필요하다. 예를 들면, 도메인 -&gt; 서비스 -&gt; UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안된다. 젠킨스에서는 이러한 빌드 파이프라인의 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능하다.</p>]]></content><author><name>GitHub User</name></author><category term="jenkins" /><category term="jenkins" /><summary type="html"><![CDATA[CI/CD]]></summary></entry><entry><title type="html">docker란?</title><link href="http://localhost:4000/docker/cloud/2022/04/25/docker.html" rel="alternate" type="text/html" title="docker란?" /><published>2022-04-25T00:00:00+09:00</published><updated>2022-04-25T00:00:00+09:00</updated><id>http://localhost:4000/docker/cloud/2022/04/25/docker</id><content type="html" xml:base="http://localhost:4000/docker/cloud/2022/04/25/docker.html"><![CDATA[<h2 id="docker">docker</h2>

<ul>
  <li>
    <p>리눅스 컨테이너를 만들고 사용할 수 있도록 하는 컨테이너화 기술 소프트웨어</p>
  </li>
  <li>
    <p>오픈소스 docker 커뮤니티는 모든 사용자가 무료로 이점으 얻을 수 있도록 기술 개선중</p>
  </li>
  <li>
    <p>docker inc. 는 docker 커뮤니티의 활동에 기반을 두고 docker 커뮤니티의 보안을 강화하고
개선 사항을 공유하여 발전시킨다</p>
  </li>
</ul>

<p>docker를 사용하면 컨테이너를 매우 가벼운 모듈식 가상머신처럼 다룰 수 있다.</p>

<p>컨테이너를 구축,배포,복사 하고 한 환경에서 다른 환경으로 이동하는 등 유연하게 사용할 수 있어
애플리케이션을 클라우두에최적화 하도록 지원한다.</p>

<h2 id="docker의-작동-방식">docker의 작동 방식</h2>

<p>docker는 리눅스 커널과 함께 Cgroups 및 네임스페이스와 같은 커널의 기능을 사용하여 프로세스를 분리함으로써
독립적으로 실행될 수 있도록 합니다.
이러한 독립성은 컨테이너의 본래 목적입니다. 다시말해서, 여러 프로세스와 애플리케이션을 서로 개별적으로 실행하여 인프라를 더
효과적을 활용하고 개별 시스템을 사용할 때와 동일한 보안을 유지할 수 있습니다.</p>

<p>docker를 포함한 컨테이너 툴은 이미지 기반 배포 모델을 제공하므로 여러 환경 전반에서 에플리케이션 또는 서비스를
모든 종속 항목과 손쉽게 공유할 수 있습니다. 또한 docker는 이 컨테이너환경 내에서 애플리케이션(또는 앱을 구성하는 결합된 프로세스)
배포를 자동화합니다.</p>

<h2 id="docker-와-리눅스-컨테이너의-차이점">docker 와 리눅스 컨테이너의 차이점</h2>

<p>docker 기술은 lXC 기술을 기반으로 구축되긴 헀으나, 그 이후 종속 관계를 벗언났습니다. 하지만 대부분 사용자는 
기존의 linux컨테이너와 연결지어 생각하고 있습니다. LXC는 경량의 가상화 방법으로 유용하게 사용되었지만 개발자 또는 사용자에게
우수한 경험을 제공하지는 못했습니다. docker 기술은 컨테이너를 실행하는 기능 이상의 것을 제공하며 무엇보다 컨테이너 생성 및 구축,
이미지 전송, 이미지 버전 관리 프로세스를 용이하게 해줍니다.</p>

<p>전통적인 linux 컨테이너는 멀티플 프로세스를 관리할 수 이는 초기화 시스템을 사용하빈다. 즉, 전체 애플리케이션을 하나로 실행할 수 있습니다
docker 기술은 애플리케이션이 개별 프로세스로 세분화 하며 이를 수행할 수 있는 툴을 제공합니다. 이 세분화된 접근 방식에는 이점이 있습니다.</p>

<h2 id="docker-컨테이너의-이점">docker 컨테이너의 이점</h2>

<h3 id="모듈성">모듈성</h3>

<p>docker 의 컨테이너화 접근 방식은 전채 애플리케이션을 분해할 필요 없이 애플리케이션의 일부를 분해하고, 업데이트 또는 복구하는 능력에 집중되어있습니다.
사용자는 이 마이크로서비스 기반 접근 방식 외에도 SOA(service-oriented architecture)의 작동방식과 동일하게 멀티플 애플리케이션 사이에서 프로세스를 공유할 수 있습니다.</p>

<h3 id="계층-및-이미지-버전-제어">계층 및 이미지 버전 제어</h3>

<p>각 docker 이미지 파일은 일련의 계층으로 이루어져 있으며 이 계층들은 단일 이미지로 결합됩니다.
이미지가 변경될 때 계층이 생성되고, 사용자가 실행 또는 복사와 같은 명령을 지정할 때마다 새 계층이 생성됩니다.</p>

<p>docker는 새로운 컨테이너를 구출할 때 이러한 계층을 재사용하므로 구축 프로ㅔ스가 훨씬 더 빨라집니다.
중간 변경 사항이 이미지 사이에서 공유되므로 속도, 규모, 효율성이 더 개선됩니다. 게층화에는 버전 관리가 내재되어 있으며
새로운 변경 사항이 발생할 때마다 내장 변경 로그가 기본적으로 적용되므로 컨테이너 이미지를 완전히 제어할 수 있습니다.</p>

<h3 id="롤백">롤백</h3>

<p>계층화에서 가장 유용한 부분은 아마도 롤백 기능일 것입니다. 모든이미지에는 계층이 있으며, 현재의 이미지 반복이 적절하지 않은 경우
이전 버전으로 롤백하면 됩니다. 이 기능을 애자일(agile) 개발 접근 방식을 지원하며 툴 관점에서 실제로 지속적인 통합 및 연속 배포
(Continuous Integration and Deployment, CI/CD)를 수행하는 데 도움을 줍니다.</p>

<h3 id="신속한-배포">신속한 배포</h3>

<p>새로운 하드웨어를 준비하고, 실행하고, 프로비저닝하고, 사용할 수 있게 하려면 일반적으로 며칠이 소요되었습니다.
많은 노력과 부가적인 업무가 필요하므로 부담도 상당했습니다. docker 기반 컨테이너는 배포 시간을 몇 초로 단축할 수 있습니다.
각 프로세스에 대한 컨테이너를 생성함으로 이동하기 위해 OS를 부팅할 필요가 없으므로 배포 시간이 크게 단축됩니다. 이뿐만 아니라 배포속도가 빨라 컨테이너에서 생성된 데이터를 비용 효율적으로 쉽게 생성하고 삭제할 수 있고 사용자는 우려를 할 필요가 없습니다.</p>

<p>즉, docker 기술은 효율성을 중시하며 더 세분화되고 제어 가능한 마이크로서비스 기반 접근 방식 입니다.</p>

<h2 id="도커-사용의-장단점">도커 사용의 장단점</h2>

<p>docker는 단이 컨테이너 관리에 적합하도록 만들어져 있습니다. 수백 개로 세분화된 컨테이너와 컨테이너화 된 앱을 점점 많이 사용하기 시작하면 관리와 오케스트레이션이 매우 어려워질 수 있습니다. 결국 모든컨테이너 전채에서 네트워킹, 보안,텔레메트리 와 같은
서비스를 제공하기 위해 한걸음 물러나서 컨테이너를 그룹화 해야 합니다. 바로 여기에 쿠버네티스가 사용됩니다.</p>

<p>docker에서는 전통적인 리눅스 컨테이너에서 제공되는 것과 동일한 unix와 같은 기능을 사용할 수 없습니다.
여기에는 컨테이너 내에서 애플리케이션과 함꼐 cron 또는 syslog 와 같은 프로세스를 사용할 수 있는 기능이 포함됩니다.
또한 자식 프로세르를 종료한 후에 손자 프로세르를 정리하는 작업 등 기존의 리눅스 컨테이너에서 기본적으로 처리되는 작업에
대한 제약이 있습니다. 이러한 문제는 처음부터 바로 드러나지는 않지만 초기에 설청 파일을 수정하고 이러한 기능을 셋업하여
완화할 수 있습니다.</p>

<p>네임스페이스가 없는 기타 리눅스 하위 시스템과 장치도 있습니다. 여기에는 SELinux, Cgroups 및/dev/sd* 장치가 포함됩니다.
그렇기 떄문에 공격자가 이러한 하위 시스템에 대한 제어 권한을 어들 경우 호스트가 손상됩니다. 경량을 유지하기 위해 호스트 커널을 컨테이너와 공유할 경우 이러한 보안 취약점이 발생할 수 있습니다. 호스트 커널은 호스트 시스템에서 훨씬 더 확실히 분리된 가상 머신과 다릅니다.</p>

<p>docker 데몬에도 보안 문제는 있을 수 있습니다. docke 컨테이너를 사용하고 실행하기 위해 가장 많이 사용하는 것이 컨테이너의 
퍼시스턴스 런타임인 docker 데몬입니다. docker 데몬을 사용하려면 루트 권한이 필요하므로 이 프로세스에 엑세스 할 수 있는 사람과
프로세르가 상주하는 위치에 각별한 주의를 기울여야 합니다. 예를들어, 로컬 데몬은 웹 서버와 같은 퍼블릭 위치에 상주하는 데몬보다
공격에 대한 취약성이 낮습니다.</p>]]></content><author><name>GitHub User</name></author><category term="docker" /><category term="cloud" /><category term="cloud" /><summary type="html"><![CDATA[docker]]></summary></entry><entry><title type="html">web 과 Was</title><link href="http://localhost:4000/http/servlet/jsp/2022/04/19/web-was.html" rel="alternate" type="text/html" title="web 과 Was" /><published>2022-04-19T00:00:00+09:00</published><updated>2022-04-19T00:00:00+09:00</updated><id>http://localhost:4000/http/servlet/jsp/2022/04/19/web-was</id><content type="html" xml:base="http://localhost:4000/http/servlet/jsp/2022/04/19/web-was.html"><![CDATA[<h2 id="web-과-was">web 과 was</h2>
<h2 id="1-web-과-was-의-차이">1. web 과 was 의 차이</h2>

<p>web 서버 : html, css, js, jpg 등 정적 데이터를 처리하는 웹 서버</p>

<p>대표 web 서버 : apache ,iis,nginx</p>

<p>was 서버 : jsp,asp,php 등 사용자의 입력을 받아 서버에서 무언가를 처리하고 보여주는 동적 웹 서버</p>

<p>대표 was 서버 : web logic, tomcat, jeus</p>

<h2 id="2-was">2. was</h2>

<p>was = web server + web container</p>

<p>was는 규모가 크고 엔터프라이즈 환경에 필요한 트랜잭션, 보안, 트랙픽관리,db커넥션 풀, 사용자 관리등 다양한 기능을 제공하는
SW를 의미한다.</p>

<p>was는 
사용자 요청(웹 브라우저) -&gt; 웹서버 -&gt; was(동적처리) -&gt; 웹서버 -&gt; 사용자 응답 메시지(웹 브라우저) 의 구성으로 이루어진다.</p>

<h1 id="3-was-가-필요한-이유">3. was 가 필요한 이유</h1>

<p>was 없이 web 만으로 모든 컨텐츠를 표현 하기 위해선 사용자가 원하는 요청에 대한 결과값을 미리 만들어 서비스 해줘야한다 이러면 서버 자원이 절대적을 부족해진다.</p>

<p>따라서 was를 통해 요청에 맞는 데이터 db를 가져와 로직에 맞게 그떄 그떄 결과를 만들어 제공함으로써 자원을 효율적으로 사용 할 수 있다.</p>

<h2 id="4-was-와-web-을-나눈-이유">4. was 와 web 을 나눈 이유</h2>

<ul>
  <li>
    <p>was는 db조회나 다양한 동적 로직들 처리하기 때문에 정적컨텐츠 까지 처리하게 되면 부하가 걸리기 쉽다 때문에 정적 컨텐츠는 web 에서 따로 처리하게 하면 부하를 줄일 수 있다.</p>
  </li>
  <li>
    <p>물리적으로 분리하여 보안을 강화 할 수 있다. SSL 에 대한 암복호화 처리에 웹 서버를 사용할수 있다.</p>
  </li>
  <li>
    <p>여러 대의 was 를 연결가능하다 -&gt; 로드 밸런싱에 웹 서버를 사용 fail over,fail back 처리에 유리하며 무중단 운영을 위한 장애극복에 쉽게 대응 가능하다. ex) 오류가 생긴 was 이용을 중단시키고 재시작 시킴 나머지 was들은 정상 작동하기 때문에 사용자는 오류를 느끼지 못하고 이용 가능하다.</p>
  </li>
  <li>
    <p>여러 웹 어플리케이션 이용가능 하나의 서버에서 PHP 어플과 JAVA 어플을 사용할 수 있다.</p>
  </li>
</ul>

<p>종합적으로 자원 효율성, 장애극복, 배포 및 유지보수 편의성 때문에 웹서버와 was를 분리하여 사용한다.</p>]]></content><author><name>GitHub User</name></author><category term="http" /><category term="servlet" /><category term="jsp" /><category term="tomcat" /><category term="apache" /><category term="nginx" /><summary type="html"><![CDATA[web 과 was 1. web 과 was 의 차이]]></summary></entry><entry><title type="html">퍼미션</title><link href="http://localhost:4000/cmd/2022/04/18/permisson-copy.html" rel="alternate" type="text/html" title="퍼미션" /><published>2022-04-18T00:00:00+09:00</published><updated>2022-04-18T00:00:00+09:00</updated><id>http://localhost:4000/cmd/2022/04/18/permisson%20copy</id><content type="html" xml:base="http://localhost:4000/cmd/2022/04/18/permisson-copy.html"><![CDATA[<h2 id="퍼미션이란">퍼미션이란</h2>

<ul>
  <li>
    <p>퍼미션 : 리눅스 보안 상의 이유로 다른 사용자들이 자신의 파일을 읽거나 쓰는 것을 제어할 수 있다. 이러한 역할을 하는것을 퍼미션이라고 한다. = 디렉토리 접근에 허가 권한 부여</p>

    <ul>
      <li>
        <p>총 10개의 문자로 표현하며, 맨앞 파일 형식을 제외한 9개의 문자로 파일 퍼미션을 나타낸다.</p>
      </li>
      <li>d : 디렉토리 , - :표준 파일</li>
      <li>r : 읽기 숫자 4</li>
      <li>w : 쓰기 숫자 2</li>
      <li>
        <p>x : 실행 숫자 1</p>
      </li>
      <li>파일구분 :  -/d/l</li>
      <li>소유자 : rw- (앞 3개)</li>
      <li>그룹 : rw- (중간 3개)</li>
      <li>이외사용자 : r– (뒤 3개)</li>
      <li>ex) 퍼미션
        <ul>
          <li>drw-r-r– : 644  디렉토리 소유자는 읽고 쓰기, 그룹에게는 읽기, 그 외 사용자는 읽기 까지만 허용.</li>
          <li>drwx——: 700  디렉토리 소유자만 읽고,쓰고,실행 허용.</li>
          <li>-rw-rw-rw-: 666  소유자, 그룹, 그외 사용자 모두 읽고 쓰기만 허용.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>chmod : 퍼미션을 바꾸기 위해 쓰는 명령어  chmod 퍼미션(숫자값) 해당 파일  로 변경</p>
    <ul>
      <li>chmod u(유저)+x+g(그룹)+x+o(이외)+w+z 해당파일 같은 방식으로도 가능</li>
    </ul>
  </li>
</ul>]]></content><author><name>GitHub User</name></author><category term="cmd" /><category term="cmd" /><summary type="html"><![CDATA[퍼미션이란]]></summary></entry><entry><title type="html">linux 명령어</title><link href="http://localhost:4000/cmd/linux/2022/04/18/linux.html" rel="alternate" type="text/html" title="linux 명령어" /><published>2022-04-18T00:00:00+09:00</published><updated>2022-04-18T00:00:00+09:00</updated><id>http://localhost:4000/cmd/linux/2022/04/18/linux</id><content type="html" xml:base="http://localhost:4000/cmd/linux/2022/04/18/linux.html"><![CDATA[<h2 id="linux-명령어">linux 명령어</h2>

<h2 id="1-lslist-segment">1. ls(list segment)</h2>

<ul>
  <li>
    <p>현재 위치의 파일 목록을 조회하는 명령어.</p>
  </li>
  <li>ls -l : 파일들의 상세 정보를 나타냅니다.</li>
  <li>ls -a : 숨어있는 파일들도 표시합니다.</li>
  <li>ls -t : 파일들을 생성된 시간별로(최신부터) 표시합니다.</li>
  <li>ls -rt: 파일들을 오래된 것 부터 표시합니다.</li>
  <li>
    <p>ls -F : 파일을 표시할 때 마지막에 유형을 나타내는 파일명을 끝에 표시합니다.</p>

    <ul>
      <li>각 옵션들은 자유자재로 합성해서 사용가능 ex) ls-lrt : 파일의 상세정보 + 오래된 것 부터 표시.</li>
    </ul>
  </li>
</ul>

<h2 id="2-cdchange-directory">2. cd(change directory)</h2>

<ul>
  <li>
    <p>cd는 경로를 이동할 떄 사용하는 명령어.</p>
  </li>
  <li>cd~ : 어느 곳에서든지 홈디렉토리로 바로 이동합니다.</li>
  <li>cd..: 상위 디렉토리로 이동합니다.</li>
  <li>cd/dir : 절대경로 dir로 이동할 경우 사용합니다.</li>
  <li>cd - : 이동하기 바로전의 디렉토리로 이동합니다.</li>
</ul>

<h2 id="3-touch">3. touch</h2>

<ul>
  <li>
    <p>touch 는 파일의 용량이 0인 파일을 생성, 날짜 변경하는 명령어.</p>
  </li>
  <li>touch filename : filename 의 파일을 생성합니다.</li>
  <li>touch -c filename : filename 의 시간을 현재시간으로 변경합니다.</li>
  <li>touch -t 202204181350 : filename 의 시간을 날짜정보(YYYYMMDDHHMM) 로 변경합니다.</li>
  <li>touch -r filename1 filename2 : filename2 의 날짜정보를 filename1 의 날짜정보와 같게 변경합니다.</li>
</ul>

<h2 id="4mkdirmake-directory">4.mkdir(make directory)</h2>

<ul>
  <li>
    <p>mkdir 은 새로운 디렉토리를 만들 때 사용하는 명령어입니다.</p>
  </li>
  <li>mkdir dirname : dirname 의 디렉토리를 생성합니다.</li>
  <li>mkidr -p dirname/subdname : 존재하지 않는 디렉토리의 하위 디렉토리까지 생성합니다.</li>
  <li>
    <p>mk -m 644 dirname : 특정 퍼미션을 갖는 디렉토리를 생성합니다.</p>

    <ul>
      <li><a href="https://hyongho.github.io/cmd/2022/04/18/permisson.html">퍼미션</a></li>
    </ul>
  </li>
</ul>

<h2 id="5cpcopy">5.cp(copy)</h2>

<ul>
  <li>
    <p>cp 는 파일을 복사하는 명령어.</p>
  </li>
  <li>cp file cfile : file 을 cfile 이라는 이름으로 복사합니다.</li>
  <li>cp -f file cfile : 복사할떄 복사대상이이 있으면 지우고 강제로 복사합니다.</li>
  <li>cp -R dir cdir : 디렉토리 복사할 떄 사용하며 , 폴더안의 모든 하위경로와 파일들을 모두 복사합니다.</li>
</ul>

<h2 id="6-mvmove">6. mv(move)</h2>

<ul>
  <li>
    <p>mv 는 파일을 이동하는 명령어.</p>
  </li>
  <li>mv fname mfname : fname 의 마일을 mfname 이름으로 이동/변경합니다.</li>
  <li>mv -b fname mfname : mfname 의 파일이 존재하면 mfname 을 백업한 뒤에 이동합니다.</li>
  <li>mv -f fname mfname : mfname 의 파일이 존재하면 백업 없이 덮어씁니다.</li>
</ul>

<h2 id="7-rmremove">7. rm(remove)</h2>

<ul>
  <li>
    <p>rm 은 파일이나 디렉토리를 삭제할 때 사용하는 명령어.</p>
  </li>
  <li>rm fname : fname 을 삭제합니다.</li>
  <li>rm -f fname : fname 을 묻지 않고 삭제합니다.</li>
  <li>rm -r dir : dir 을 삭제합니다.
    <ul>
      <li>디렉토리는 -r 옵션 없이 삭제 불가능.</li>
    </ul>
  </li>
</ul>

<h2 id="8catcatenate">8.cat(catenate)</h2>

<ul>
  <li>
    <p>cat 은 파일이름을 인자로 받아서 그 내용을 출력할 떄 사용.</p>
  </li>
  <li>
    <p>cat fname : fname 의 내용을 출력합니다.</p>
  </li>
  <li>
    <p>cat fname1 fname2 : fname1 과 fname2 의 내용을 이어서 출력합니다.</p>
  </li>
  <li>
    <p>cat fname1 fname2 |more: fname1,fname2 를 출력하는데 페이지별로 출력합니다.</p>
  </li>
  <li>
    <p>cat fname1 fname2 |head: fname1,fname2 를 출력하는데 처음부터 10번쨰 까지만 합니다.</p>
  </li>
  <li>
    <p>cat fname1 fname2 |tail: fname1,fname2 를 출력하는데 끝에서부터 10번째 까지만 출력합니다.</p>
  </li>
</ul>

<h2 id="9redirection">9.redirection(‘&gt;’,’»’)</h2>

<ul>
  <li>
    <p>rediretion 은 리눅스 스트림 방향을 조정하는 명령어</p>
  </li>
  <li>
    <p>명령 &gt; 파일 : 명령의 결과를 파일로 저장합니다.</p>

    <ul>
      <li>cat fname1 fname2 &gt; fname3: fname1, fname2 를 출력하고 fname3 이라는 파일에 저장합니다.</li>
    </ul>
  </li>
  <li>
    <p>명령 » 파일 : 명령의 결과를 파일에 추가합니다.</p>

    <ul>
      <li>cat fname4 » fname3: fname3 에 fname4 의 내용을 추가합니다.</li>
    </ul>
  </li>
  <li>
    <p>명령 &lt; 파일 : 파일의 데이터를 명령에 입력합니다.</p>

    <ul>
      <li>
        <p>cat &lt; fname1 : fname1 의 내용을 출력합니다.</p>
      </li>
      <li>
        <p>cat &lt; fname1 &gt; fname2 : fname1 의 내용을 출력하는 결과물을 fname2 에 저장합니다.</p>
      </li>
    </ul>

    <h2 id="10alias">10.alias</h2>

    <ul>
      <li>
        <p>alias 는 자주 사용하는 명령어를 간단한 명령어로 설정하는 명령어 해제시 -&gt; unalias</p>
      </li>
      <li>
        <p>alias new =”command” : command 를 실행하는 새 명령어 new 를 만듭니다.</p>

        <ul>
          <li>ex) alias ls=’ls-l’ : ls 를 실행하면 -l 옵션을 갖는 ls 를 실해합니다.</li>
        </ul>
      </li>
      <li>
        <p>alias : 현재 alias 목록을 출력합니다.</p>
      </li>
      <li>
        <p>unalias new : new 라는 alias 를 해제 합니다.</p>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>GitHub User</name></author><category term="cmd" /><category term="linux" /><category term="cmd" /><category term="linux" /><summary type="html"><![CDATA[linux 명령어]]></summary></entry><entry><title type="html">fetch API 데이터 정제</title><link href="http://localhost:4000/http/json/2022/04/14/fetch.html" rel="alternate" type="text/html" title="fetch API 데이터 정제" /><published>2022-04-14T00:00:00+09:00</published><updated>2022-04-14T00:00:00+09:00</updated><id>http://localhost:4000/http/json/2022/04/14/fetch</id><content type="html" xml:base="http://localhost:4000/http/json/2022/04/14/fetch.html"><![CDATA[<h2 id="fetch-api">Fetch API</h2>

<p>Fetch API 를 이용하면 Request 나 Resoponse 같은 HTTP 파이프라인을 구성하는 요소를 조작하는것이 가능하다.</p>

<p>fetch() (en-US) 메서드를 이용하여 비동기 네트워크 통신을 알기쉽게 기술할 수 있다.</p>

<p>fetch() 의 기본 스펙은 JQuery.ajax() 와 기본적으로 두가지가 다르다.</p>

<ol>
  <li>
    <p>fetch() 로 부터 반환되는 Promise 객체는 HTTP error 상태를 reject 하지않는다 (HTTP 상태코드가 404 나 500이더라도 안한다) 대신 ok 상태가 false 인 resolve 가 반환되며 네트워크 장애나 요청이 완료되지 못한상태에는 reject가 반환된다.</p>
  </li>
  <li>
    <p>fetch는 쿠키를 보내거나 받지 않는다 사이트에서 사용자 세션을 유지 관리해야 하는 경우 인증되지 않은 요청이 발생한다. 쿠키를 전송하기 위해서는 자격증명(credentials) 옵션으 반드시 설정해야 한다.</p>
  </li>
</ol>

<p>기본적인 fetch 코드</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(JSON.stringify(myJson));
  });
  //네트워크에서 JSON 파일을 가져와서 콘솔에 인쇄하는 코드
</code></pre></div></div>

<p>간단한 fetch() 사용 흐름은 인수 한개(가져올 자원의 경로)를 가져오고 응답을 포함하는 약속(Response (en-US)개체)을 반환하는것 이것은 단순한 HTTP Response 이며, 실제 JSON이 아니다.</p>

<p>response 객체로부터 사진을 가져오기 위해서는 json() (en-US) 메서드를 사용할 필요가 있다.
body의 믹스인 으로 정의되어, Request 객체와  Response (en-US) 객체의 쌍방에 구현되어 있다.</p>

<h2 id="fetch-로-비동기-http-get-하기">fetch 로 비동기 HTTP GET 하기</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('http://210.109.63.156:9000/sample02')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson){
</code></pre></div></div>

<p><a href="http://210.109.63.156:9000/sample02">http://210.109.63.156:9000/sample02</a></p>

<p>위 샘플 HTTP 의 JSON을 GET 해와서 myJson으로 변수 선언후 초기화하였다.</p>

<h3 id="json-데이터-가공하기">Json 데이터 가공하기</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"recordsFiltered":0,"data":[{"d_name":"시간별 전력 사용량","create_date":"8일 10 : 00","value":24.77},{"d_name":"시간별 전력 사용량","create_date":"8일 10 : 30","value":34.72},{"d_name":"시간별 전력 사용량","create_date":"8일 11 : 00","value":52.22},{"d_name":"시간별 전력 사용량","create_date":"8일 11 : 30","value":53.69},{"d_name":"시간별 전력 사용량","create_date":"8일 12 : 00","value":39.18},{"d_name":"시간별 전력 사용량","create_date":"8일 12 : 30","value":23.14},{"d_name":"시간별 전력 사용량","create_date":"8일 13 : 00","value":22.97},{"d_name":"시간별 전력 사용량","create_date":"8일 13 : 30","value":13.08}],"result_cd":"200","result_data":[{"d_name":"시간별 전력 사용량","create_date":"8일 10 : 00","value":24.77},{"d_name":"시간별 전력 사용량","create_date":"8일 10 : 30","value":34.72},{"d_name":"시간별 전력 사용량","create_date":"8일 11 : 00","value":52.22},{"d_name":"시간별 전력 사용량","create_date":"8일 11 : 30","value":53.69},{"d_name":"시간별 전력 사용량","create_date":"8일 12 : 00","value":39.18},{"d_name":"시간별 전력 사용량","create_date":"8일 12 : 30","value":23.14},{"d_name":"시간별 전력 사용량","create_date":"8일 13 : 00","value":22.97},{"d_name":"시간별 전력 사용량","create_date":"8일 13 : 30","value":13.08}],"draw":1,"recordsTotal":0}
</code></pre></div></div>

<p>샘플 HTTP 에 담긴 데이터를 원하는 정보와 형식으로 가공하려고 한다.</p>

<p>샘플 HTTP 의 type을 typeof 로 확인 한 결과 [object object] 타입으로 나왔다.</p>

<p>object 형태의 데이터에 각각 recodesFitered, data, result_cd, draw, recordsTotal 의 key 가 있으며, 각 key들 또한 [object object], number 형태의 vlaue를 담고 있는 것을 알 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('http://210.109.63.156:9000/sample02')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson){

length = myJson.data.length;
B=[];
A=[];
for(i=0; i&lt;length; i++){
    B.push(myJson.data[i].value);
    A.push(myJson.data[i].create_date);
}
</code></pre></div></div>

<p>여기서 내가 필요로 하는 데이터는 “data” 라는 key 안에 있으므로 myjson.data 를 하여 myjson 의 “data” 키에 있는 value 들 만 불러오도록 한다.</p>

<p>data 안에 value 들 또한 object 이므로 각 object 안에서도 원하는 데이터가 있는 key 인 vlaue 와 create_date 만 뽑아 내도록 하였다.</p>

<p>myJson.data.length 를 하여 data key에 있는 value(object 형식으로 된) 의 갯수를 확인.</p>

<p>A 와 B 의 배열을 선언 초기화 해주고 for 문을 통해 각 object(“data”의 value) 안의 value(“data”의 value  인 object 안의 key 명) 와 create_data  라는 이름을 가진 key의 데이터를 각각 A와 B 배열 안에 push 해주어 저장해주었다.</p>

<ul>
  <li>배열.push = 배열의 마지막 자리에 데이터를 넣어줌.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A =[8일 10 : 00,8일 10 : 30,8일 11 : 00,8일 11 : 30,8일 12 : 00,8일 12 : 30,8일 13 : 00,8일 13 : 30];

B =[24.77,34.72,52.22,53.69,39.18,23.14,22.97,13.08];
</code></pre></div></div>
<p>위와 같이 json 에서 필요한 데이터를 A, B 배열로 가공하여 차트에 활용할 수 있게 되었다.</p>]]></content><author><name>GitHub User</name></author><category term="HTTP" /><category term="JSON" /><category term="HTTP" /><category term="JSON" /><summary type="html"><![CDATA[Fetch API]]></summary></entry><entry><title type="html">HTTP API 동기/비동기</title><link href="http://localhost:4000/http/api/2022/04/14/API.html" rel="alternate" type="text/html" title="HTTP API 동기/비동기" /><published>2022-04-14T00:00:00+09:00</published><updated>2022-04-14T00:00:00+09:00</updated><id>http://localhost:4000/http/api/2022/04/14/API</id><content type="html" xml:base="http://localhost:4000/http/api/2022/04/14/API.html"><![CDATA[<h2 id="http">HTTP</h2>

<p>두 컴퓨터 간에 텍스트 데이터를 주고 받는 길</p>

<p>요청: 작성 게시물 텍스트 데이터를 HTTP를 통해 back-end 컴퓨터로 보내고 back-end 컴퓨터에게
이 데이터를 데이터 베이스에 저장해달라고 요청한다.</p>

<p>응답: 요청을 받은 back-end 컴퓨터가 성공, 실패 등 처리 결과를 응답한다 back-end 컴퓨터는 응답할 떄,
응답 상태코드를 보낸다.</p>

<p>응답 상태코드</p>

<p>100 ~ 599 = 까지의 숫자로 구성</p>

<p>200 = 성공</p>

<p>400 front-end = 에러</p>

<p>500 back-end  = 에러</p>

<h2 id="api">API</h2>

<p>API 란 HTTP 요청을 back-end 컴퓨터에 보냈을 떄 실행되는 back-end 기능이다.
데이터 요청을 받고 응답을 주는 담당자.</p>

<h2 id="api-종류">API 종류</h2>

<p>네이버에서 1번 게시글을 조회 할 때.</p>

<p>rest- API = 주소처럼 생긴 이름 ex) http://naver.com/board/1</p>

<p>graphql-API = 일반 함수와 같은 이름 ex) board(1)</p>

<h2 id="rest-api">rest-API</h2>

<p>응답 결과로 back-end 개발자가 만든 함수에서 보내주는 모든 데이터를 받아야한다.</p>

<p>rest-API 에 요청하는 요청담당자: axios</p>

<h2 id="graphql-api">graphql-API</h2>

<p>응답 결과로 back-end 개발자가 만든 함수에서 필요한 데이터만 골라받을 수 있다.</p>

<p>필요한 데이터만 골라 받을 수 있어서, 효율적인 통신을 할 수 있다.</p>

<p>graphql-API 에 요청하는 요청 담당자: apollo-client</p>

<p>요청담당자: front-end 에서 설치하는 라이브러리</p>

<h2 id="api를-구분하는-4가지-방식">API를 구분하는 4가지 방식</h2>

<ol>
  <li>새로운 것을 생성하는 API -&gt; create</li>
  <li>기존 것을 조회하는 API  -&gt; read</li>
  <li>기존 것을 수정하는 API  -&gt; update</li>
  <li>기존 것을 삭제하는 API  -&gt; delete</li>
</ol>

<h3 id="생성create">생성(create)</h3>

<p>axios(rest-API) = post</p>

<p>apollo-client(graphql-API) = mutation</p>

<h3 id="수정update">수정(update)</h3>

<p>axios(rest-API) = put</p>

<p>apollo-client(graphql-API) = mutation</p>

<h3 id="삭제delete">삭제(delete)</h3>

<p>axios(rest-API) = delete</p>

<p>apollo-client(graphql-API) = mutation</p>

<h3 id="조회read">조회(read)</h3>

<p>axios(rest-API) = get</p>

<p>apollo-client(graphql-API) = query</p>

<h4 id="rest-api-1">rest-API</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import axios from "axios"

const result = axios.post(API name) // create

const result = axios.get(https://naver.com/board1) // read

const result = axios.put(https://naver.com/board1) // update

const result = axios.delete(https://naver.com/board1) // delete
</code></pre></div></div>

<p>back-end 에서 주는대로 front-end에서 다 받아온다.</p>

<h4 id="graphql-api-1">graphql-API</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useMutaion , useQuery } form '@apollo/client'

const result = useMutaion(API name)

const result = useQuery(API name)
</code></pre></div></div>

<p>back-end에서 골라서 front-end 에서 받는다.</p>

<h2 id="api-명세서">API 명세서</h2>

<p>back-end 개발자 에게 받는 API 사용 설명서</p>

<h2 id="api-요청-결과-타입json">API 요청 결과 타입(JSON)</h2>

<p>자바스크립트 객체 표기법 JSON(JavaScript Object Notation)</p>

<p>API 요청의 결과가 자바스크립트의 객체처럼 표기되어 JSON이라 부른다.</p>

<h2 id="동기비동기">동기/비동기</h2>

<p>서버와 데이터를 주고 받는 2가지 방식</p>

<h3 id="동기">동기</h3>

<p>서버 컴퓨터가 작업이 끝날 때까지 기다리는 통신</p>

<p>한번에 하나씩 통신</p>

<p>응답이 모두 끝난 후 요청</p>

<h3 id="비동기">비동기</h3>

<p>서버 컴퓨터가 작업이 끝날 떄까지 기다리지 않는 통신</p>

<p>서버에 요청(등록,수정,삭제 등) 저장이 될 때까지 기다리지 않고 다른 작업 진행</p>

<p>동시에 여러개 통신</p>

<p>오래 걸리는 일(이메일 전송, 다운로드 받으면서 메신저하기)</p>

<h2 id="비동기를-동기로-바꿔주는-명령어-async-await">비동기를 동기로 바꿔주는 명령어 async/ await</h2>

<p>rest_API  또는 graphql-API를 사용해서 요청에 대한 응답을 받는 객체(JSON)를 변수에 담아서 사용한다.</p>

<p>응답결과를 변수에 담아서 사용하려면 통신이 완료될 떄까지 기다려야한다.</p>

<p>이 때 async/await를 활용하여 기다려야한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//비동기 통신
async function 함수(){
    axios('API nmae') //서버 컴퓨터 요청(기다리지 않음)
}

//동기 통신
async function 함수(){
    await axios('API name') // 서버 컴퓨터에 요청(기다림)
}
</code></pre></div></div>

<h3 id="promise">Promise</h3>

<p>자바스크리트 비동기 처리에 사용되는 객체</p>

<p>API가 실행되면 서버에다가 요청을 보내는데 받아오기도 전에 화면에 데이터를 표시하려 하면 오류가 
발생하거나 빈화면이 뜸</p>

<p>Promise는 비동기적으로 실행하는 작업의 결과를 나타내는 객체이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//비동기 통신

async funciton 함수(){
    const data = axios.get('https://adadjson.com/posts/1')

    cosnlole.log(data)

    //Promise

}

//동기 통신

async funcion 함수(){

    const data = await axio.get('https://adadjson.com/posts/1')

    cosnlole.log(data)

    //{id:1}

}
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="HTTP" /><category term="API" /><category term="HTTP" /><category term="API" /><summary type="html"><![CDATA[HTTP]]></summary></entry></feed>